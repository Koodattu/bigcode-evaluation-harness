[{"slug_name": "spiral-matrix", "meta_info": {"data": {"question": {"categoryTitle": "Algorithms", "content": "<p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>Output:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n", "difficulty": "Medium", "questionFrontendId": "54", "questionId": "54", "questionTitle": "Spiral Matrix", "questionTitleSlug": "spiral-matrix", "similarQuestions": "[{\"title\": \"Spiral Matrix II\", \"titleSlug\": \"spiral-matrix-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Spiral Matrix III\", \"titleSlug\": \"spiral-matrix-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Spiral Matrix IV\", \"titleSlug\": \"spiral-matrix-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]", "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"2.6M\", \"totalAcceptedRaw\": 1260175, \"totalSubmissionRaw\": 2618561, \"acRate\": \"48.1%\"}", "topicTags": [{"name": "Array", "slug": "array"}, {"name": "Matrix", "slug": "matrix"}, {"name": "Simulation", "slug": "simulation"}]}}}, "id": "54", "difficulty": "Medium", "pretty_content": ["Given an m x n matrix, return all elements of the matrix in spiral order.\n\n\u00a0\nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\n\nExample 2:\n\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\n\u00a0\nConstraints:\n\n\n\tm == matrix.length\n\tn == matrix[i].length\n\t1 <= m, n <= 10\n\t-100 <= matrix[i][j] <= 100\n\n\n"], "solutions": [{"hash": -7901417908281767226, "runtime": "44ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \n        top = left = 0\n        bottom = len(matrix)-1\n        right = len(matrix[0])-1\n        ans = []\n        while left<=right and top<=bottom:\n\n            for i in range(left,right+1):\n                ans.append(matrix[top][i])\n\n            top +=1\n\n            for i in range(top,bottom+1):\n                ans.append(matrix[i][right])\n\n            right-=1\n\n            if top<= bottom:\n\n                for i in range(right,left-1,-1):\n                    ans.append(matrix[bottom][i])\n\n                bottom-=1\n\n            if left<=right:\n\n                for i in range(bottom,top-1,-1):\n                    ans.append(matrix[i][left])\n\n                left+=1\n\n        return ans"}, {"hash": 2979623801820750370, "runtime": "36ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix or not matrix[0]:\n            return []\n\n        result = []\n        top, bottom = 0, len(matrix) - 1\n        left, right = 0, len(matrix[0]) - 1\n\n        while left <= right and top <= bottom:\n            # Traverse top row\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n\n            # Traverse right column\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n\n            # Traverse bottom row\n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n\n            # Traverse left column\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n\n        return result"}, {"hash": 5830702755919632550, "runtime": "24ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix:\n            return []\n\n        rows, cols = len(matrix), len(matrix[0])\n        top, bottom, left, right = 0, rows-1, 0, cols-1\n        result = []\n        \n        while len(result) < rows * cols:\n            for i in range(left, right+1):\n                result.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                result.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n        \n        return result"}, {"hash": 6143528053069974267, "runtime": "56ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        result = []\n        while matrix:\n            result += (matrix.pop(0))\n            if matrix and matrix[0]:\n                result += ([row.pop() for row in matrix])\n            if matrix:\n                result += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                result += ([row.pop(0) for row in matrix][::-1])\n        return result"}, {"hash": -6407230161003952030, "runtime": "60ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        result = []\n        while matrix:\n            result += matrix.pop(0)\n            matrix = (list(zip(*matrix)))[::-1]\n        return result"}, {"hash": 471172117717305173, "runtime": "68ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        res = []\n        left,right = 0, len(matrix[0])\n        top , bottom = 0,len(matrix)\n        while left < right and top < bottom:\n            #from left to right\n            for a in range(left, right):\n                res.append(matrix[top][a])\n            top +=1\n            \n            #from top to bottom \n            for a in range(top , bottom):\n                res.append(matrix[a][right-1])\n            right -=1\n            \n            #break loop if we dont have left to right\n            if not (left < right and top < bottom):\n                break\n            \n            #from right to left\n            for a in range(right-1 , left-1 , -1):\n                res.append(matrix[bottom-1][a])\n            bottom -=1\n            # break\n            \n            #from bottom to up \n            for a in range(bottom-1, top-1, -1):\n                res.append(matrix[a][left])\n            left +=1\n        \n        return res"}, {"hash": -4981930739436859778, "runtime": "20ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        first_row = 0\n        last_row = len(matrix) - 1\n        first_col = 0\n        last_col = len(matrix[0]) - 1\n\n        output = []\n\n        while True:  # Revisit\n            # top\n            output.extend(matrix[first_row][first_col:last_col + 1])\n            first_row += 1\n\n            if first_row > last_row:\n                break\n\n            # right\n            for i in range(first_row, last_row + 1):\n                output.append(matrix[i][last_col])\n            last_col -= 1\n\n            if first_col > last_col:\n                break\n\n            # bottom\n            output.extend([matrix[last_row][j] for j in range(last_col, first_col-1, -1)])\n            last_row -= 1\n\n            if first_row > last_row:\n                break\n\n            # left\n            for k in range(last_row, first_row - 1, -1):\n                output.append(matrix[k][first_col])\n            first_col += 1\n\n            if first_col > last_col:\n                break\n\n        return output"}, {"hash": -4488399605146645399, "runtime": "52ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        row , col = len(matrix), len(matrix[0])\n        u, d, l, r = 0, row-1, 0, col-1\n        ans = []\n        while len(ans) < (row*col):\n            for i in range(l, r+1):\n                ans.append(matrix[u][i])\n            u += 1\n\n            for i in range(u, d+1):\n                ans.append(matrix[i][r])\n            r -= 1\n\n            if u <= d:\n                for i in range(r, l-1, -1):\n                    ans.append(matrix[d][i])\n                d -= 1\n            if l <= r:\n                for i in range(d, u-1, -1): \n                    ans.append(matrix[i][l])\n                l+=1\n        return ans"}, {"hash": -7303749964658191738, "runtime": "64ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        ans = []\n        # boundaries\n        left, right = 0, len(matrix[0])-1\n        top, bottom = 0, len(matrix)-1\n\n        while left <= right and top <= bottom:\n            # right\n            for c in range(left, right+1):\n                ans.append(matrix[top][c])\n            top += 1\n            \n            # down\n            for r in range(top, bottom+1):\n                ans.append(matrix[r][right])\n            right -= 1\n\n            if not (left <= right and top <= bottom):\n                break\n\n            # left\n            for c in range(right, left-1, -1):\n                ans.append(matrix[bottom][c])\n            bottom -= 1\n\n            # up\n            for r in range(bottom, top-1, -1):\n                ans.append(matrix[r][left])\n            left += 1\n\n        return ans"}, {"hash": 2531128780300420629, "runtime": "28ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        result =[]\n        if len(matrix) ==1:\n            return matrix[0]\n        if len(matrix)==0:\n            return []\n        result += matrix.pop(0)\n        print(result)\n        if len(matrix)!=0 and len(matrix[0])!=0:\n            for row in range(len(matrix)):\n                result.append(matrix[row].pop(-1))\n        print (result)\n        if len(matrix)!=0 and len(matrix[-1])!=0:\n            a=matrix.pop(-1)\n            a.reverse()\n            result +=a\n        print(result)\n        print(matrix)\n        if len(matrix)!=0 and len(matrix[0])!=0:\n            col1 = []\n            for row in range (len(matrix)):\n                col1.append(matrix[row].pop(0))\n            col1.reverse()\n            result+=col1\n        print(result)\n        print(matrix)\n        result+=self.spiralOrder(matrix)\n        print(result)\n        return result\n        "}, {"hash": 1625463847752106776, "runtime": "48ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        ans = []\n\n        leftToRightStartIndex = 0\n        leftToRightEndIndex = len(matrix[0])\n\n        upToDownStartIndex = 0\n        upToDownEndIndex = len(matrix)\n\n        rightToLeftStartIndex = len(matrix[0]) - 1\n        rightToLeftEndIndex = 0\n\n        downToUpStartIndex = len(matrix) - 1\n        downToUpEndIndex = 1\n\n        while leftToRightStartIndex <= rightToLeftStartIndex and upToDownStartIndex <= downToUpStartIndex:\n            for iterator in range(leftToRightStartIndex, leftToRightEndIndex):\n                ans.append(matrix[upToDownStartIndex][iterator])\n\n            for iterator in range(upToDownStartIndex + 1, upToDownEndIndex):\n                ans.append(matrix[iterator][rightToLeftStartIndex])\n\n            if upToDownStartIndex < downToUpStartIndex:\n                for iterator in range(rightToLeftStartIndex - 1, rightToLeftEndIndex - 1, -1):\n                    ans.append(matrix[downToUpStartIndex][iterator])\n\n            if leftToRightStartIndex < rightToLeftStartIndex:\n                for iterator in range(downToUpStartIndex - 1, upToDownStartIndex, -1):\n                    ans.append(matrix[iterator][leftToRightStartIndex])\n\n            leftToRightStartIndex += 1\n            leftToRightEndIndex -= 1\n            upToDownStartIndex += 1\n            upToDownEndIndex -= 1\n            rightToLeftStartIndex -= 1\n            rightToLeftEndIndex += 1\n            downToUpStartIndex -= 1\n            downToUpEndIndex += 1\n\n        return ans\n\n\n\n\n\n\n            \n\n\n        "}, {"hash": 1359650924783587915, "runtime": "40ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        m, n = len(matrix), len(matrix[0])\n        row_t, row_b, col_l, col_r = 0, m-1, 0, n-1\n        res = []\n\n        while row_t <= row_b and col_l <= col_r:\n            # Go through top row\n            for j in range(col_l, col_r + 1):\n                res.append(matrix[row_t][j])\n\n            # Go through last col, starting at 2nd to first row\n            for i in range(row_t + 1, row_b + 1):\n                res.append(matrix[i][col_r])\n\n            # Go through last row, starting at 2nd to last col\n            if row_t != row_b: # If row_t == row_b, we've already gone through the last row since it's also the first row\n                for j in range(col_r - 1, col_l - 1, -1):\n                    res.append(matrix[row_b][j])\n\n            # Go through first col, starting at 2nd to last row up to the 2nd to first row\n            if col_l != col_r: # If col_l == col_r, we've already gone through the first col since it's also the last col\n                for i in range(row_b - 1, row_t, -1):\n                    res.append(matrix[i][col_l])\n\n            row_t, row_b, col_l, col_r = row_t + 1, row_b - 1, col_l + 1, col_r - 1\n\n        return res\n\n# Time Complexity: O(mn)        Go through all elements\n# Space Complexity: O(mn)       Will store all elements in res array"}, {"hash": -5179929568505095957, "runtime": "32ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        m, n = len(matrix), len(matrix[0])\n        res = []\n        for o in range(0, min(m, n) // 2 + 1):\n            left = o\n            right = n- o - 1\n            up = o\n            down = m - o - 1\n            print(left, right, up, down)\n            if down < up or right < left:\n                continue\n            #if up == down and left == right:\n            #    res.append(matrix[up][left])\n            #    continue\n            for j in range(left, right):\n                res.append(matrix[up][j])\n            if up == down:\n                res.append(matrix[up][right])\n                continue\n            for i in range(up, down):\n                res.append(matrix[i][right])\n            if left == right:\n                res.append(matrix[down][right])\n                continue\n            for j in range(right, left, -1):\n                res.append(matrix[down][j])\n            for i in range(down, up, -1):\n                res.append(matrix[i][left])\n        return res"}, {"hash": -5842837003432617729, "runtime": "14ms", "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        xmin = -1\n        xmax = len(matrix)\n        ymin = -1\n        ymax = len(matrix[0])\n        x = y = 0\n        res = [matrix[0][0]]\n\n        while xmin <= xmax and ymin <= ymax:\n            for i, direction in enumerate([[0,1],[1,0],[0,-1],[-1,0]]):\n                while xmin < x + direction[0] < xmax and ymin < y + direction[1] < ymax:\n                    x += direction[0]\n                    y += direction[1]\n                    res.append(matrix[x][y])\n                if i == 0:\n                    xmin += 1\n                elif i == 1:\n                    ymax -= 1\n                elif i == 2:\n                    xmax -= 1\n                elif i == 3:\n                    ymin += 1\n                if xmin + 1 == xmax or ymin + 1 == ymax:\n                    break\n        return res"}], "prompt": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n", "generator_code": "import random\n\ndef generate_test_case():\n    m = random.randint(1, 10)\n    n = random.randint(1, 10)\n    return [[random.randint(-100, 100) for _ in range(n)] for _ in range(m)]", "convert_online": "def convert_online(case):\n    return case", "convert_offline": "def convert_offline(case):\n    return case", "evaluate_offline": "def evaluate_offline(inputs, outputs, expected):\n    if outputs == expected:\n        return True\n    \n    return False", "entry_point": "spiralOrder", "test_cases": "[{\"input\": [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]], \"expected\": [1, 2, 3, 6, 9, 8, 7, 4, 5]}, {\"input\": [[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]], \"expected\": [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]}, {\"input\": [[[37, 48, 94, 7], [33, 94, -38, 97], [79, -96, -77, 93], [52, 77, 72, -23], [-24, 72, -45, -74], [2, 37, 4, -89], [5, 60, 61, 44], [-24, 52, 19, 1], [-1, -50, 33, 57], [-58, -56, 15, -13]]], \"expected\": [37, 48, 94, 7, 97, 93, -23, -74, -89, 44, 1, 57, -13, 15, -56, -58, -1, -24, 5, 2, -24, 52, 79, 33, 94, -38, -77, 72, -45, 4, 61, 19, 33, -50, 52, 60, 37, 72, 77, -96]}, {\"input\": [[[29, -85, -35, 22, -41, 58, -13, -5, 31], [-15, -77, 24, 100, 26, -85, -60, -79, -23], [-20, -94, -24, -96, 37, -22, 92, -93, 67], [36, -36, -31, -90, 41, -70, 56, 8, 60], [66, 12, 53, -88, 40, 43, 91, 70, 33], [2, -98, -16, -18, -28, 89, -68, -53, 20], [87, 15, -54, -99, 13, -62, -85, 82, 57], [-39, -35, 51, 0, -95, -29, -49, -38, -100], [-89, 87, 55, -67, -6, -38, 65, -20, -69]]], \"expected\": [29, -85, -35, 22, -41, 58, -13, -5, 31, -23, 67, 60, 33, 20, 57, -100, -69, -20, 65, -38, -6, -67, 55, 87, -89, -39, 87, 2, 66, 36, -20, -15, -77, 24, 100, 26, -85, -60, -79, -93, 8, 70, -53, 82, -38, -49, -29, -95, 0, 51, -35, 15, -98, 12, -36, -94, -24, -96, 37, -22, 92, 56, 91, -68, -85, -62, 13, -99, -54, -16, 53, -31, -90, 41, -70, 43, 89, -28, -18, -88, 40]}, {\"input\": [[[60, 61, 48, -97, -96, -25], [-89, -13, 45, 5, -88, -71], [-31, -23, 11, -22, 82, -27], [-90, -82, -27, -86, -99, -10], [58, -54, 66, 63, 100, 8], [100, 76, -20, 0, -50, 93], [-16, -57, 33, -15, 95, 100]]], \"expected\": [60, 61, 48, -97, -96, -25, -71, -27, -10, 8, 93, 100, 95, -15, 33, -57, -16, 100, 58, -90, -31, -89, -13, 45, 5, -88, 82, -99, 100, -50, 0, -20, 76, -54, -82, -23, 11, -22, -86, 63, 66, -27]}, {\"input\": [[[-14, -12, 26, 65, -89, 86, 18, 18, -82, -28], [-47, -42, -79, -10, 34, 70, -85, -16, 95, -6], [28, -84, 10, 98, 30, 56, -76, -52, -22, 47]]], \"expected\": [-14, -12, 26, 65, -89, 86, 18, 18, -82, -28, -6, 47, -22, -52, -76, 56, 30, 98, 10, -84, 28, -47, -42, -79, -10, 34, 70, -85, -16, 95]}, {\"input\": [[[39, 92, 43, 74, -77, -64], [3, -76, -24, 94, 93, 65], [-70, -81, -11, 52, -34, 61], [-98, 83, 79, 92, 31, -99]]], \"expected\": [39, 92, 43, 74, -77, -64, 65, 61, -99, 31, 92, 79, 83, -98, -70, 3, -76, -24, 94, 93, -34, 52, -11, -81]}]"}]